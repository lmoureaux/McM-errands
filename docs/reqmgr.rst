.. SPDX-FileCopyrightText: Louis Moureaux <louis.moureaux@cern.ch>
.. SPDX-License-Identifier: AGPL-3.0-or-later

The Request Manager
===================

The Request Manager, or `ReqMgr2 <https://cmsweb.cern.ch/reqmgr2/index>`_,
manages CMS computing jobs and distributes them across the Grid. When producing
new datasets, McM submits requests to the Request Manager like one would do to
any batch system, except they run on the Grid and are tightly integrated with
CMSSW and the CMS data storage. This page documents the structure of the tasks
submitted by McM.

Every Monte-Carlo production in CMS starts from a ``cmsDriver.py`` command line.
McM is, at its core, a tool to prepare the list of ``cmsDriver.py`` commands
needed to produce a dataset and submit them to the Request Manager for
production. Separate commands are typically used every processing step leading
to a file ready for analysis: event generation, detector simulation, trigger
system emulation, reconstruction and formatting as NANOAOD. Each of them gets
submitted as a separate task to the Request Manager.

.. _config-cache:

The Configuration Cache
-----------------------

The Request Manager cannot run ``cmsDriver.py`` commands directly. Instead, one
needs to upload a CMSSW configuration file to a separate database called the
Configuration Cache. The Configuration Cache is a CouchDB database storing
simple metadata about a configuration file in its documents and the files
themselves as attachments. Entries in the Configuration Cache are referred to
using the ID of the corresponding CouchDB documents.

The configuration files are obtained by running ``cmsDriver.py`` with additional
arguments to instruct it to store the configuration. Unfortunately, some of the
metadata needed by the Configuration Cache requires a second pass through the
configuration to inspect the output modules generated by ``cmsDriver.py``. This
is done using the `wmupload script`_. These two steps have to be run in a CMSSW
environment matching the one used to execute the configuration.

.. _wmupload script: https://github.com/cms-PdmV/wmcontrol/blob/master/wmupload.py


.. _task-specification:

Specifying Tasks
----------------

In Request Manager jargon, an execution of a ``cmsDriver.py`` command (or
rather, of an entry from the :ref:`Configuration Cache <config-cache>`) is
called a Step or a Task (see :ref:`task-step-chains` for the distinction). Tasks
and Steps have additional metadata in order for the Request Manager
to know where to run the task, what to do with the produced events, and
facilitate McM bookkeeping. They are specified as a JSON object with the keys
listed below.

.. note::
    This is a curated list for McM usage. Documentation can be found on the
    `Request Manager wiki`_ and technical specifications in the
    `ReqMgr2 repository`_.

.. _Request Manager wiki: https://github.com/dmwm/WMCore/wiki/Request-Types-Arguments
.. _ReqMgr2 repository: https://github.com/dmwm/WMCore/tree/master/doc/createSpecs

Metadata
^^^^^^^^

``TaskName`` or ``StepName``
    A unique identifier for the task, which can contain pretty much anything as
    long as it is a string.

``ConfigCacheID``
    The ID of the configuration stored in the Configuration Cache.

``Campaign``
    A string used to group similar tasks together. Each campaign name has to be
    enabled explicitly by the computing team, which PdmV requests through a JIRA
    ticket. Running "pilot" request is needed to demonstrate that the campaign
    works as intended.

    .. todo:: Pilot requests are currently not documented.

``AcquisitionEra``
    A string that will be added to name of any output dataset (see
    :ref:`Dataset Names <dataset-names>` for more). McM sets this to the name of
    the campaign.

``PrepID``
    A name for PdmV bookkeeping, used by Stats2 and McM to map back to where the
    task originated from.

Datasets
^^^^^^^^

``KeepOutput``
    Whether the events should be stored as a new dataset.

``GlobalTag``
    The ``--conditions`` parameter of ``cmsDriver.py``.

``MCPileup``
    The full path (``/dataset/processing/DATATIER``) of a secondary dataset used
    for pileup mixing.

``PrimaryDataset``
    If the output is to be saved, this is used as the first part of the dataset
    name. See :ref:`Dataset Names <dataset-names>` for more.

``ProcessingString``
    Used in the second part of the dataset name. This is in most cases identical
    to the global tag, but can sometimes contain more information. See
    :ref:`Dataset Names <dataset-names>` for more.

``ProcessingVersion``
    This field is set when for some reason a dataset needs to be produced more
    than once. This can be used by computing when recovering failed tasks, or by
    McM itself. Also used as part of the dataset name, see
    :ref:`Dataset Names <dataset-names>` for more.

Generator Tasks
^^^^^^^^^^^^^^^

The Request Manager supports submitting multiple Tasks or Steps running
sequentially on the same events. For the first Task or Step, one needs to
specify additional information about the input:

``InputDataset``
    If provided, specifies that events from an existing dataset will be
    reprocessed. This should contain the full path as shown in DAS.

``LheInputFiles``
    Whether the Task or Step uses LHE files stored on EOS.

``RequestNumEvents``
    The number of events to produce.

``Seeding``
    McM sets this explicitly to ``AutomaticSeeding`` for generator tasks. This
    is also the Request Manager default.

    .. todo:: And what does it mean?

.. _processing-tasks:

Processing Tasks
^^^^^^^^^^^^^^^^

The Request Manager supports submitting multiple Tasks or Steps running
sequentially on the same events. Tasks after the first are called
`Processing Tasks` and one needs to specify where their input should come from.
See :ref:`chaining-tasks` for how McM fills these fields:

``InputTask`` or ``InputStep``
    Which other task (in the same submission) should provide events to this one.

``InputFromOutputModule``
    Which CMSSW output module the events should be taken from.

Performance Information
^^^^^^^^^^^^^^^^^^^^^^^

In order to split jobs optimally and direct the Task to an appropriate site, the
Request Manager needs some information about the resources needed for
processing. For Steps, this information is provided for each submission as a
whole (see :ref:`task-step-chains`).

``FilterEfficiency``
    The average efficiency of event production: some tasks may discard some
    events, in which case this is smaller than 1.

    .. todo::
        Can apparently also be specified for Steps, although McM does not do it.

``Memory``
    The maximum amount of memory needed by the Task, in megabytes.

``SizePerEvent``
    The average size of events produced by the Task, in kilobytes.

``TimePerEvent``
    The time needed to produce one event, in seconds.

    .. todo:: Is there some normalization for older CPU models?

Job Splitting
^^^^^^^^^^^^^

Request Manager job splitting is very similar to CRAB. The `CRAB documentation`_
is hence a useful resource.

``SplittingAlgo``
    How the processing should be split in jobs. McM uses ``EventBased`` for
    generator Tasks and Steps and ``EventAwareLumiBased`` otherwise.

``EventsPerLumi``
   How many events should be included in each LumiSection.

.. _CRAB documentation: https://twiki.cern.ch/twiki/bin/view/CMSPublic/CRAB3ConfigurationFile

Technical
^^^^^^^^^

``CMSSWVersion``
    The version of CMSSW in which to run the task, e.g.
    ``CMSSW_10_2_12_patch1``.

``EventStreams``  (optional)
    The number of event streams used by the configuration. Identical to the
    corresponding ``cmsDriver.py`` argument, if present.

``Multicore``
    The number of threads to allocate for the request.

``ScramArch``
    A list of scram architectures the request can run in. McM always uses the
    `official architecture`_ for the corresponding CMSSW release.

.. _official architecture: https://cmssdt.cern.ch/SDT/cgi-bin/ReleasesXML?anytype=1


.. _dataset-names:

Dataset Names
-------------

Dataset names in CMS follow a strict convention, to which McM contributes
several ingredients (although the definitive name is determined by computing).
The pattern is easiest to understand from an example:

.. code-block:: text

    /ADDGravToLL_LambdaT-10000_M-1300To2000_13TeV-pythia8/RunIIFall17DRPremix-PU2017_94X_mc2017_realistic_v11_ext1-v3/AODSIM

The path can be split in three parts. The first one specifies the physics
process contained in the dataset and is fully used-defined following guidelines
established by the generator group. McM specifies it as the ``PrimaryDataset``
parameter to Tasks and Steps. The last part is the data format, which is
passed to ``cmsDriver.py`` when building the configuration (as the
``--datatier`` argument).

The middle segment is a composite string built from several inputs provided by
McM. Everything before the first hyphen, ``RunIIFall17DRPremix``, is the name of
the campaign used to produce the dataset, coming from the ``AcquisitionEra``
parameter. The version number after the last hyphen is the
``ProcessingVersion``. Between them is a free text string where McM stores three
inputs:

* Any customisations (flows) used on top of the campaigns that deviate from the
  defaults. The names are defined by the PdmV group and separated by
  underscores. In the present case, the additional settings were about pileup.
* The global tag, here ``94X_mc2017_realistic_v11``.
* If the dataset is an extension of another one, this information is also added
  by appending ``_extN``.

This part of the string is passed to the Request Manager through the
``ProcessingVersion`` Task or Step parameter.

The convention described above uses a few separator characters: slashes,
hyphens, and underscores. These should be avoided when they could make the
parsing ambiguous. The precise rules enforced by computing are as follows:

===================== ========================= =========== ====================
Parameter             Characters                Length      Notes
===================== ========================= =========== ====================
Dataset names         Letters, numbers, _-      1 to 99     Starts with a letter
Acquisition eras      Letters, numbers, _       Not empty   Starts with a letter
Campaign names        Letters, numbers, _       1 to 100
Processing strings    Letters, numbers, _       1 to 100
Task and step names   Letters, numbers, _-      1 to 50     Starts with a letter
Request names         Letters, numbers, _-, dot 1 to 150
CMSSW versions        ``CMSSW_a_b_c(_x)?``
Global tags           ``a-zA-Z0-9\s\.\-_:``
===================== ========================= =========== ====================

In addition, the middle part of a dataset name including the acquisition era,
the processing string, and the version number, may not be longer than 199
characters. It also cannot start with ``None``, and as a consequence this
applies to acquisition eras as well.

.. note::
    These restrictions are defined in the `Request Manager "Lexicon"`_ source
    file.

.. _Request Manager "Lexicon": https://github.com/dmwm/WMCore/blob/2.2.0.7/src/python/WMCore/Lexicon.py

.. _chaining-tasks:

Chaining Tasks and Steps
------------------------

When multiple ``cmsDriver.py`` commands need to be executed one after the other,
it is possible to send a chain of Tasks or Steps to the Request Manager. To
understand how this is done, one needs to dive into the internals of CMSSW and
``cmsDriver.py``.

A single execution of CMSSW can be used to produce multiple kinds of output
datasets simultaneously. Each output corresponds to an ``OutputModule`` added to
the configuration. In order to chain a Task or Step after another, one needs to
specify the Task or Step to retrieve the input from as well as the correct
output module (see :ref:`processing-tasks`). This is where things get
complicated, because there is no way in CMSSW to specify the data format
expected as input.

McM circumvents this problem by maintaining a hand-crafted list of what kind of
outputs can be used for what kind of processing (the `datatier_input`_ setting).
When pairing Tasks or Steps one after another, it looks at the first processing
step in the second command and tries to match it with the output of the first
command. If it cannot find a match, it falls back to the first output of the
first command and hopes for the best.

.. _datatier_input: https://cms-pdmv.cern.ch/mcm/settings?prepid=datatier_input

.. note::
    At the time of this writing, irrelevant content appears to have been added
    to the ``datatier_input`` dictionary, conflating datatiers and event
    contents. All commands inspected by the author use a single output module
    and most of them use the fallback code path.

    Restricting McM support to ``cmsDriver.py`` commands with a single output
    module and relying on the user not screwing things up would allow to get rid
    of this brittle implementation.

In order to determine which output module is present in a configuration, McM
inspects the ``cmsDriver.py`` command and relies on their conventional name
being ``TYPEoutput``, where ``TYPE`` is the name of the event type passed to
``cmsDriver.py``.


Request Injection and Approval
------------------------------

Submitting Tasks or Steps to the Request Manager is done by uploading a
JSON file to the service, containing the Tasks and Steps definition as well as
some additional metadata described below. This is done using an old script
called `wmcontrol`_, which essentially posts it (as in HTTP ``POST``) to
``https://cmsweb.cern.ch/reqmgr2/data/request``. The endpoint returns a JSON
object containing the request ID. Like for most of the Request Manager,
authentication using an X.509 grid certificate is required.

.. _wmcontrol: https://github.com/cms-PdmV/wmcontrol/blob/master/wmcontrol.py

.. note::
    ``wmcontrol.py`` will refuse to submit a request without any saved output.

After a request has been successfully injected, it still needs to be approved
before it can start running. This is done by making an HTTP ``PUT`` request to
``https://cmsweb.cern.ch/reqmgr2/data/request/<Request ID>`` with content
``{"RequestStatus": "assignment-approved"}``, which initiates the
`Request Manager State Machine`_.

.. _Request Manager State Machine:
    https://cms-pdmv.gitbook.io/project/computing/untitled-2

.. note::
    It is unclear whether McM could initiate other Request Manager state
    transitions directly. :ref:`Force Complete <reqmgr-force-complete>` is
    currently handled in a completely different way.

Submission Format
^^^^^^^^^^^^^^^^^

The JSON file submitted to the Request Manager contains a single dictionary with
the following keys:

``Group``
    The group doing the request, for McM this is always ``ppd``.

``Requestor``
    The user doing the request, for McM this is always the PdmV service account,
    a.k.a. ``pdmvserv``.

``Multicore``
    McM always sets this to 1.

``PrepID``
    An arbitrary name for PdmV bookkeeping. McM sets this to ``task_`` followed
    by the PrepID of the chained request or request used when submitting.

``ProcessingVersion``
    McM always sets this to 1.

``RequestPriority``
    The priority assigned to the request, as an integer between 0 and 10000. McM
    sets this from the Step or Task with the highest defined priority.

``RequestString``
    An arbitrary name. McM sets this to the same value as ``PrepID``

``SubRequestType``
    Set to ``Pilot``, ``ReDigi``, or ``MC`` according to what the Steps or Tasks
    need and in this order of priority.

``TaskN`` or ``StepN``
    For increasing ``N`` starting from 1, the tasks being submitted, see
    :ref:`task-specification`.

``TaskChain`` or ``StepChain``
    The number of Tasks (resp. Steps) beings submitted.

The following values are copied from the fist Task or Step:
``AcquisitionEra``,
``ProcessingString``, and
``ScramArch``.

The following values are copied from the last Task or Step:
``AcquisitionEra``,
``Campaign``,
``CMSSWVersion``,
``GlobalTag``,
``Memory``,
``ProcessingString``
``ScramArch``,
``SizePerEvent``, and
``TimePerEvent``.


.. _task-step-chains:

Task and Step Chains
--------------------

McM uses two modes of operation of the Request Manager called Task Chain and
Step Chain. Both allow the submission of a chain of multiple Tasks (for Task
Chains) or Steps (for Step Chains) to be run in sequence over each event. They
differ in the way the commands are executed: a Task Chain runs them
sequentially, while a Step Chain is able to run them concurrently on a single
machine. The Request Manager wiki has a `detailed comparison`_. McM does not
implement any automatic decision-making regarding Task or Step Chains and leaves
the choice to the user, as a property of each Chained Campaign.

.. _detailed comparison: https://github.com/dmwm/WMCore/wiki/TaskChain-vs-StepChain

Task Chain and Step Chain submissions have a lot in common, except for a few
fields changing name or being moved around. Any Task Chain can be turned into a
Step Chain, but this is a destructive operation and the reverse is not possible.
The main differences are summarized below:

* The ``RequestType`` must be set to ``TaskChain`` or ``StepChain`` as
  appropriate;
* ``Task`` in the name of any property becomes ``Step``;
* ``TimePerEvent`` and ``SizePerEvent`` are added up for all Steps and moved to
  the top level.

In addition to these transformations, McM replaces any occurrence of ``task`` in
values with ``step``. The reason for this is obscure.


.. _reqmgr-force-complete:
.. _reqmgr-invalidate:

Forced Completion and Invalidation
----------------------------------

It is needed to stop the production of a sample before it is complete, for
instance when jobs get stuck and cannot be recovered easily. In such cases, the
``force-complete`` state transition in the `Request Manager State Machine`_ can
be used. This is done in McM by adding the relevant PrepID to a list that the
CMS Unified daemon checks every hour.

Another action following this pattern is dataset invalidation. Here, the list
can contain either requests or datasets. The CMS Unified daemon checks the list
of invalidations every hour and triggers an ``abort`` or ``reject`` transition
(in addition to invalidating all linked datasets). Finally, McM recieves an
acknowledgement informing it that the action was performed.
